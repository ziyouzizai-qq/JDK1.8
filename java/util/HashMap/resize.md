```
主要讲这两个算法的作用

e.hash & (newCap - 1)：计算索引值

e.hash & oldCap：由于扩容数组，就需要将旧数组里的元素的hash计算出新的索引值，从而放入新数组中
但是，官方并没有直接e.hash & (newCap - 1)去计算索引值。看下面实例讲解为什么要这么做？


假设 oldCap = 16 ，由于扩容 newCap = 32
e.hash假设为    00000000 00000000 00000000 00001100 或者 ... 00011100


计算旧索引
    oldCap - 1  00000000 00000000 00000000 00001111     00000000 00000000 00000000 00001111
&   e.hash      00000000 00000000 00000000 00001100     00000000 00000000 00000000 00011100
-------------------------------------------------------------------------------------------
                00000000 00000000 00000000 00001100     00000000 00000000 00000000 00001100

两个不同的hash值算出的索引值一样，这个时候会产生链表结构,拿上面例子举例，不管你前三个高位如何的变化，按位与算法，索引值都只看后四位1。
其实这样做是可行的，因为newCap - 1是数组下标最大值，你只能从0~newCap - 1中选择索引，这就是为什么要按位与。


扩容之后再次计算新索引值（官方并没有这么做）
计算新索引
    newCap - 1  00000000 00000000 00000000 00011111     00000000 00000000 00000000 00011111
                                              v                                       v 
&   e.hash      00000000 00000000 00000000 00001100     00000000 00000000 00000000 00011100
-------------------------------------------------------------------------------------------
                00000000 00000000 00000000 00001100     00000000 00000000 00000000 00011100
你会发现索引值不一样了，箭头指向的那个位置是不是非常关键，由于每次都是左移1位扩容，就决定hash值与之对位的值尤为关键。
可以发现，第一个hash值的索引值是旧索引值，而第二个hash值是旧索引值+旧数组长度。

所以说，结论：新数组的索引值就两种情况，这就是为什么官方不进行重新计算新数组索引，但是如何确定前一位是0还是1。
官方用e.hash & oldCap。现在我假设oldtable[0]中是链表结构，有7个节点，如果你能理解到这儿，心里应该有想法了，
这7个节点重新放到新的数组，就两个位置，旧索引或者是旧索引值+旧数组长度，扩容后这两个位置的元素节点数量之和一定是7。
所以说接下来的操作就是拼接节点，还要注意原本的顺序。但是我该如何知道这两个位置各有几个节点呢？用e.hash & oldCap计算
    oldCap      00000000 00000000 00000000 00010000     00000000 00000000 00000000 00010000
                                              v                                       v
&   e.hash      00000000 00000000 00000000 00001100     00000000 00000000 00000000 00011100
-------------------------------------------------------------------------------------------
                00000000 00000000 00000000 00000000     00000000 00000000 00000000 00010000
算出的值不是0就是oldCap
0的情况： 说明箭头位是0 ==========> 旧索引值
oldCap：  说明箭头位是1 ==========> 旧索引值+旧数组长度

分析出来是不是该拼链表了，有可能是一个节点一个链表，比方说(1,6)。也有可能是一个链表(0,7)。还有可能是两个链表(3,4)，
这要看各个节点的箭头位了。
但是我应该遵循先前的顺序拼接吧，假设这7个节点，1,2,3,4,5,6,7。
旧索引：3,1,7
旧索引值+旧数组长度：4,5,6,2
但是拼的时候
旧索引：1,3,7
旧索引值+旧数组长度：2,4,5,6
这才是正确顺序，回源码分析
注意，官方是先拼，拼完节点后在挂到对应位置上。
```